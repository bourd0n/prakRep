В ширину

Time limit:	2 s
Memory limit:	128 M
Вам предлагается, выполнив все представленные далее задания, разработать и реализовать ряд классов для решения различных задач над графовыми структурами данных методом обхода графа в ширину. Под графовыми структурами данных будут пониматься такие структуры данных, которые могут быть представлены в виде множества элементов, связанных друг с другом. Примерами таких структур данных могут быть списки, деки (двусвязные списки), деревья, собственно графы и т.д. Любую такую структуру данных можно "обходить" в определенном порядке, в частности, в ширину.

Идея в том, чтобы разработать и реализовать такой набор интерфейсов и классов, который даст возможность быстрого решения новых задач над описанными выше структурами данных за счет переиспользования большой части кода путем наследования от этих интерфейсов и классов.

Как и в прошлых задачах вам не разрешается использовать операции приведения типа и instanceof. Кроме того вам не разрешается использовать generic классы без указания типовых параметров.

Подзадача 1.

Из определения элемента структуры данных следует, что ее можно определить, реализовав такой интерфейс:

interface Vertex {
   Iterable<Vertex> children();
}
Предположим, что мы описываем ту структуру данных, которую будем обходить в ширину. Для этого описываем класс элемента этой структуры данных, назовем его V: class V implements Vertex { ... }. Описываемая структура данных должна обладать "однородной" структурой, т.е. вершины, достижимые из другой вершины, должны иметь одинаковые типы. В частности, если тип вершины V, то и "дети" вершины должны иметь тип V (а не Vertex). Если же "дети" вершины будут иметь тип Vertex, то придется использовать приведение типа, что неудобно и ведет к ошибкам. Действительно, если class V implements Vertex { ... }, то в классе V типом результата метода children() будет Iterable<Vertex>, а не Iterable<V>.

Модифицируйте определение интерфейса Vertex, чтобы тип возвращаемого значения метода children() позволял получать и использовать его элементы в классах-потомках без операции приведения типа.

Подзадача 2.

Интерфейс java.lang.Iterable позволяет итерироваться по объекту, класс которого реализует этот интерфейс. Например, по элементам списка можно итерироваться (от первого к последнему). Интерфейс java.lang.Iterable<T> содержит метод iterator(). Он возвращает объект, класс которого реализует интерфейс java.lang.Iterator<T>. У этого объекта можно вызывать методы для получения очередного элемента, проверять существование очередного элемента и т.п. Подробнее вы можете ознакомиться с интерфейсом java.lang.Iterator<T> в документации. Обратите внимание, что этот интерфейс является generic.

Обратите, также, внимание, что коллекции из пакета java.util реализуют интерфейс java.lang.Iterable<T>.

Обход в ширину - это тоже принцип итерирования по элементам графовой структуры данных. Поэтому в этой подзадаче вам предлагается реализовать класс DepthFirstIterator<T>, реализующий интерфейс java.lang.Iterator<T>, позволяющий итерироваться по графовой структуре (обходить ее в ширину) из элементов, класс которых может быть произвольным, реализующим интерфейс Vertex. Итерирование начинается с некоторого объекта Vertex. Иными словами, этот итератор должен строить такую последовательность элементов (объектов Vertex), которая соответствовала бы обходу вширь графовой структуры данных, начиная с некоторого ее элемента.

Вам нужно реализовать такой обход в ширину, при котором каждый элемент будет встречаться не более 1 раза в последовательности элементов, генерируемой итератором.

Подзадача 3.

Определите класс ориентированных графов, класс вершин которого реализует интерфейс Vertex. Определите в этом классе метод depthFirstIterator(), принимающий в качестве параметра объект вершины графа и возвращающий объект класса DepthFirstIterator<T>. Этот объект должен позволять итерироваться по ориентированному графу в ширину, начиная с указанной вершины.

Подзадача 4.

Определите класс Reducer, выполняющий операции над последовательностью элементов, которая генерируется каким-нибудь итератором (ниже описано, как). Класс должен содержать метод reduce(), получающий три параметра:

объект итератор, класс которого реализует интерфейс java.lang.Iterator<T> (итератор нужен для получения последовательности объектов);
объект-обработчик объекта из последовательности; типом объекта-обработчик должен быть interface с методом do(); этот метод принимает вторым параметром объект из последовательности, а тип первого параметра совпадает с типом результата этого метода;
объект i0, тип которого совпадает с типом результата метода do().
Метод reduce() должен вычислять значение такого выражения: do(... do(do(do(i0, i1), i2), i3), ... ), где i1, i2, i3, ... это последовательность, которую генерирует итератор. Тем самым, метод do() обрабатывает один (очередной) объект из последовательности, а метод reduce() последовательно вызывает do() для объектов из неё.

Из сказанного следует, что тип возвращаемого значения метода reduce() должен совпадать с типом возвращаемого значения метода do().

Вам хорошо знакомы операции из математики, которые определяются точно так же, как метод reduce(). Например, суммирование последовательности чисел (тут i0 = 0, а do(r, x) = r + x).

Подзадача 5.

Реализуйте класс Solver с методом solve(), который получает на вход объект - ориентированный граф и два объекта-вершины графа и возвращает true тогда и только тогда, когда вторая вершина достижима из первой вершины в графе. Метод solve() должен быть реализован при помощи метода reduce().

Подзадача 6.

Реализуйте в классе Solver метод main(), который читает со стандартного ввода ориентированный граф и набор пар вершин и для каждой указанный пары вершин проверяет, достижима ли вторая вершины из первой. Граф вводится следующим образом: сначала идет число дуг графа, затем для каждой дуги идут два слова - идентификатор вершины, из которой исходит дуга, и идентификатор вершины, в которую идет дуга. Других вершин и дуг в графе, кроме указанных, нет. После графа идут пары идентификаторов вершин, для которых проверяется достижимость. Количество дуг и пар вершин для проверки не превышает 10000 каждое.

Метод main() должен вывести для каждой пары идентификаторов вершин один из трех знаков:

знак "+", если вторая вершина достижима из первой;
знак "-", если вторая вершина не достижима из первой;
знак "?", если хотя бы один из указанных идентификаторов не обозначает существующую вершину в указанном графе.
Подзадача 7.

Нетрудно заметить, что при определении достижимости вершины графа не всегда нужно обходить вcе вершины, достижимые из той вершины, откуда ведется поиск. Как только искомая вершина встречена, можно прекращать обход графа.

Реализуйте в классе Reducer метод reduce2(), который получает в качестве параметров те же параметры, что и метод reduce(), и ещё один параметр объект-обработчик завершения итератора, и вычисляет ту же функцию, что и reduce(), но проверяя для каждого очередного объекта от итератора условие завершения (при помощи объекта-обработчика). Если условие выполнено, reduce2() возвращает последний полученный результат метода do(). В противном случае reduce2() ведет себя так же, как и reduce(). Типом объекта-обработчика завершения итератора является interface, содержащий метод, получающий на вход текущий результат, и возвращающий boolean, если нужно прекратить итерирование и объявить этот результат итоговым результатом вычисления.

Используйте метод reduce2() в методе main() вместо метода reduce().

Обратите внимание, в ejudge посылка может содержать только один файл. Поэтому вам нужно будет поместить все классы в один файл, причем метод main() должен быть определен в публичном классе и этот класс должен идти первым.

Examples

Input	Output
3
A B
B C
D D
A C
A D
A E
+
-
?
1
B A
B B
+

